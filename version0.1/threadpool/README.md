半同步/半反应堆线程池
===================
使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它
* 同步I/O模拟Proactor模型
    * 主线程和内核负责读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求
    * 工作流程（以epoll_wait为例）：
        * 主线程往epoll内核事件表注册socket上的读就绪事件
        * 主线程调用epoll_wait等待socket上有数据可读
        * 当socket上有数据可读，epoll_wait通知主线程，主线程从socket循环读取数据，直到没有更多数据可读，然后将读取的数据封装成一个请求对象并插入请求队列
        * 主线程调用epoll_wait等待socket可写
        * 当socket上有数据可写，epoll_wait通知主线程，主线程往socket上写入服务器处理客户请求的结果
* 半同步/半反应堆
    * 工作流程（以Proactor为例）：
        * 主线程充当异步线程，负责监听所有socket上的事件
        * 若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
        * 如果连接socket上有读写事件发生，主线程从socekt上接收数据，并将数据封装成请求对象插入到请求队列中
        * 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权
* 线程池